#version 300 es

precision highp float;

uniform sampler2D tex0;

uniform vec3 vGain;


// The shader is called on a surface of unknown size on a screen
// That's why the texture coords are generated by pixels with random coordinates
void main()
{
	// int (resulting in floor) maps the whole texture coordinate range of a single pixel down to integer index
	float fX = gl_TexCoord[0].s*4096.0f; // FragCoord can not be used here as it returns window relative coordinates
	float fY = gl_TexCoord[0].t*3000.0f; // while the textured quad can be anyware inside the window
	
	// Minification
	//  _________________________
	// | | | | | | | | | | | | | |  <- texels
	// 
	//  _________________________
	// |                         |  <- pixel
	//              ^ 
	//            texture coordinate is sent from the center of the pixel

	// The texel here is random, what matters is either it is even or odd

	// G            B
	// t01 o------o t11
	//     |      |
	//     |      |
	// t00 o------o t10
	// R            G

	if (mod(fX,2.0) > 0.1f) // odd column searches backward
	{	
		if (mod(fY,2.0) > 0.1f)
		{
			vec4 t00 = texelFetch(tex0, ivec2(fX-1.0, fY-1.0), 0);
			vec4 t10 = texelFetch(tex0, ivec2(fX,     fY-1.0), 0);
			vec4 t11 = texelFetch(tex0, ivec2(fX,     fY),     0);
			vec4 t01 = texelFetch(tex0, ivec2(fX-1.0, fY),     0);

			// upper right corner
			gl_FragColor = vec4(vGain.r*t00.r, vGain.g*(t10.r+t01.r)/2.0f, vGain.b*t11.r, 1.0);
		}
		else
		{
			vec4 t00 = texelFetch(tex0, ivec2(fX-1.0, fY),     0);
			vec4 t10 = texelFetch(tex0, ivec2(fX,     fY),     0);
			vec4 t11 = texelFetch(tex0, ivec2(fX,     fY+1.0), 0);
			//vec4 t01 = texelFetch(tex0, ivec2(fX-1.0, fY+1.0), 0);

			// lower right corner
			gl_FragColor = vec4(vGain.r*t00.r, vGain.g*t10.r, vGain.b*t11.r, 1.0);
		}
	}
	else // even column searches forward
	{
		if (mod(fY,2.0) > 0.1f)
		{
			vec4 t00 = texelFetch(tex0, ivec2(fX,     fY-1.0), 0);
			//vec4 t10 = texelFetch(tex0, ivec2(fX+1.0,   fY-1.0), 0);
			vec4 t11 = texelFetch(tex0, ivec2(fX+1.0, fY),  0);
			vec4 t01 = texelFetch(tex0, ivec2(fX,     fY),  0);

			// upper left corner
			gl_FragColor = vec4(vGain.r*t00.r, vGain.g*t01.r, vGain.b*t11.r, 1.0);
		}
		else
		{
			vec4 t00 = texelFetch(tex0, ivec2(fX,     fY),     0);
			vec4 t10 = texelFetch(tex0, ivec2(fX+1.0, fY),     0);
			vec4 t11 = texelFetch(tex0, ivec2(fX+1.0, fY+1.0), 0);
			vec4 t01 = texelFetch(tex0, ivec2(fX,     fY+1.0), 0);

			// lower left corner
			gl_FragColor = vec4(vGain.r*t00.r, vGain.g*(t01.r+t10.r)/2.0f, vGain.b*t11.r, 1.0);
		}
	}

}
